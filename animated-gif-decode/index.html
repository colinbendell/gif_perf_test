<!doctype html>
<html>

<head>
    <title>Image Decode & Visual Timings</title>

    <style type="text/css">
        thead tr td {font-size: 1.5em; text-align: center;}
        TD { padding: 0.15em 0.3em; }
        .timing { font-size: 1.5em; text-align: right; }
        .timeval {
            font-size: 1.5em;
            color: orange;
            font-weight: bold;
            text-align: right;
            white-space: nowrap;
        }
        .desc {
            font-family: monospace;
            font-size: 0.4em;
            font-style: italic;
        }
        .examples {
            margin-top: -2em;
            margin-bottom: 1em;
            margin-left: 5em;
        }
        a {
            color: orange;
        }
        #testimg img {
            width: 100%;
        }
    </style>

</head>

<body style="width: 900px; font-family: helvetica, arial; background: #000; color: #FFF;">

    <h1 style="margin-left: 3em; font-size: 2.5em;">Animated Gif Comparison</h1>
    <div class="examples">
        <a href="#1.gif" target="_blank">river</a>
        <a href="#2.gif" target="_blank">life of pi</a>
        <a href="#3.gif" target="_blank">bladerunner</a>
        <a href="#4.gif" target="_blank">matrix</a>
        <a href="#5.gif" target="_blank">robots</a>
        <a href="#6.gif" target="_blank">peaky blinders</a>
        <a href="#7.gif" target="_blank">handmaid's tale</a>
        <a href="#8.gif" target="_blank">Lebowski</a>
    </div>

    <div id=testimg style="float: left; background: white; padding: 4px; width:800px; height:450px;max-width:800px; max-height:450px;min-width:800px; min-height:450px;">

    </div>

    <table style="clear: both;">
        <thead>
        <tr>
            <td></td>
            <td><a href="gif.html">GIF</a></td>
            <td><a href="webp.html">WebP</a></td>
            <td><a href="avif.html">AVIFs</a></td>
            <td>WebM<br/>(av1)</td>
            <td><a href="mp4.html">MP4<br/>(avc1)</a></td>
            <td>MP4<br/>(hvc1)</td>
        </tr>
        </thead>
        <tr> <td class=timing><div>Bytes:</div><div class="desc" >resource.encodedByteSize</div></td> <td class="timeval" id=bytes_0>...</td><td class="timeval" id=bytes_1></td><td class="timeval" id=bytes_2></td><td class="timeval" id=bytes_3></td><td class="timeval" id=bytes_4></td><td class="timeval" id=bytes_5></td> </tr>
        <tr> <td class=timing><div>TRANSFER:</div><div class="desc" >resource.responseEnd() - resource.responseStart</div></td> <td class="timeval" id=resourcetiming_0>...</td><td class="timeval" id=resourcetiming_1></td><td class="timeval" id=resourcetiming_2></td><td class="timeval" id=resourcetiming_3></td><td class="timeval" id=resourcetiming_4></td><td class="timeval" id=resourcetiming_5></td> </tr>
        <tr> <td class=timing><div>ONLOAD:</div><div class="desc" >img.onLoad() - resource.responseStart</div></td> <td class="timeval" id=onloadhandler_0>...</td><td class="timeval" id=onloadhandler_1></td><td class="timeval" id=onloadhandler_2></td><td class="timeval" id=onloadhandler_3></td><td class="timeval" id=onloadhandler_4></td><td class="timeval" id=onloadhandler_5></td> </tr>
        <tr> <td class=timing><div>RAF:</div><div class="desc" >requestAnimationFrame() - resource.responseStart</div></td> <td class="timeval" id=raf_0>...</td><td class="timeval" id=raf_1></td><td class="timeval" id=raf_2></td><td class="timeval" id=raf_3></td><td class="timeval" id=raf_4></td><td class="timeval" id=raf_5></td> </tr>
        <tr> <td class=timing><div>DECODE:</div><div class="desc" >img.decode() - resource.responseStart</div></td> <td class="timeval" id=decode_0>...</td><td class="timeval" id=decode_1></td><td class="timeval" id=decode_2></td><td class="timeval" id=decode_3></td><td class="timeval" id=decode_4></td><td class="timeval" id=decode_5></td> </tr>
        <tr> <td class=timing><div>ELEMENT TIMING:</div><div class="desc" >PerformanceElementTiming.renderTime - resource.responseStart</div></td> <td class="timeval" id=element_0>...</td><td class="timeval" id=element_1></td><td class="timeval" id=element_2></td><td class="timeval" id=element_3></td><td class="timeval" id=element_4></td><td class="timeval" id=element_5></td> </tr>
    </table>

    <p id="debug_navtiming">
    </p>
    <script>
        const TEST_GROUPS=[".gif", ".webp", ".avif", ".webm", ".mp4", "_hvc1.mp4"];
        const TEST_RUNS=10;
        let perfEntries = [];
        let results = [];

        //helper promise to sleep
        function sleep(duration, val) {
            return new Promise(resolve => {
                setTimeout(resolve.bind(null, val), duration)
            });
        }
        const observer = new PerformanceObserver((list) => {
            perfEntries.push(...list.getEntries());
        });
        if (PerformanceObserver.supportedEntryTypes.includes('element')) {
            observer.observe({entryTypes: ['resource', 'element'], buffered: true});
        }
        else if (PerformanceObserver.supportedEntryTypes.includes('resource')) {
            observer.observe({entryTypes: ['resource'], buffered: true});
        }

        // helper method for finding the median in a list of numbers (filtering out non numbers)
        function median(values) {
            values = values
                .slice(0)
                .filter(value => Number(value) === value)
                .sort( function(a, b) {return a - b; } );

            return middle(values);
        }

        // helper method to find the middle value in a list
        function middle(values) {
            let len = values.length;
            let half = Math.floor(len / 2);

            if(len % 2)
                return (values[half - 1] + values[half]) / 2.0;
            else
                return values[half];
        }

        function formatMetric(value, round = 0, unit = "ms", empty="&#x1F6AB;", prefix="") {
            if (!!value && Number(value) === value) {
                value = Math.round(value*(10**round) + Number.EPSILON)/(10**round);
            }
            if (!!value) {
                return `${prefix}${value} ${unit}`;
            }

            return empty;
        }
        function reportMetric(name, value, min = null, max = null, round = 0, unit = "ms") {
            if (!!value && Number(value) === value)
                value = Math.round(value*(10**round) + Number.EPSILON)/(10**round);

            let valueText = formatMetric(value, round, unit);
            let minValue = formatMetric(min, round, unit, "");
            let maxValue = formatMetric(max, round, unit, "");

            document.getElementById(name).innerHTML = `<div>${valueText}</div><div class="desc" style="float:left">${minValue}</div><div class="desc" style="float:right">${maxValue}</div>`;
        }

        async function endTest(test, waitCounter = 0) {
            // add resource perfEntry
            test.perf = perfEntries.filter(v => v.entryType === 'resource' && test.url === v.name)[0];
            // add element perfEntry
            test.elementPerf = perfEntries.filter(v => v.entryType === 'element' && test.url === v.url)[0];

            let isReady = test.onErrorEnd || (test.onLoadEnd && test.perf && test.rafEnd);
            if (!isReady && waitCounter < 3) {
                // sometimes (safari) doesn't load the Performance getEntries in time. why?
                await sleep(200);
                return await endTest(test, ++waitCounter);
            }

            // performance.timeOrigin is not reliable for long running page. why??
            let testStart = test.perf ? test.perf.responseStart : test.testStart;

            //basic duration values
            if (test.onLoadEnd) test.onloadDur = test.onLoadEnd - testStart;
            if (test.decodeEnd) test.decodeDur = test.decodeEnd - testStart;
            if (test.rafEnd) test.rafDur = test.rafEnd - testStart;
            if (test.elementPerf) test.elementDur = test.elementPerf.renderTime - test.perf.responseStart;
            if (test.perf) {
                test.resourceDur = Math.round(test.perf.duration || 0);
                test.resourceBytes = test.perf.decodedBodySize;
            }
            if (!test.resourceBytes) {
                let res = await fetch(test.url);
                test.resourceBytes = res.headers.get("content-length");
            }

            // report current Test Results
            let testIndex = Math.floor(results.length / TEST_RUNS);
            results.push(test);

            let testSet = results.slice(testIndex*TEST_RUNS, (testIndex + 1) * TEST_RUNS - 1);
            reportMetric(`bytes_${testIndex}`, !test.resourceBytes ? null : Math.round(test.resourceBytes / 1024 / 1024 * 100)/100, null, null, 1, 'MB');
            reportMetric(`resourcetiming_${testIndex}`, test.resourceDur);
            reportMetric(`decode_${testIndex}`, test.decodeDur);
            reportMetric(`onloadhandler_${testIndex}`, test.onloadDur);
            reportMetric(`raf_${testIndex}`, test.rafDur);
            reportMetric(`element_${testIndex}`, test.elementDur);

            // if last in the set, update to the median results (the last run won't be shown)
            if (results.length % TEST_RUNS === 0 || test.onErrorEnd) {

                reportMetric(`resourcetiming_${testIndex}`, median(testSet.map(v => v.resourceDur)), Math.min(...testSet.map(v => v.resourceDur)), Math.max(...testSet.map(v => v.resourceDur)));
                reportMetric(`decode_${testIndex}`, median(testSet.map(v => v.decodeDur)), Math.min(...testSet.map(v => v.decodeDur)), Math.max(...testSet.map(v => v.decodeDur)));
                reportMetric(`onloadhandler_${testIndex}`, median(testSet.map(v => v.onloadDur)), Math.min(...testSet.map(v => v.onloadDur)), Math.max(...testSet.map(v => v.onloadDur)));
                reportMetric(`raf_${testIndex}`, median(testSet.map(v => v.rafDur)), Math.min(...testSet.map(v => v.rafDur)), Math.max(...testSet.map(v => v.rafDur)));
                reportMetric(`element_${testIndex}`, median(testSet.map(v => v.elementDur)), Math.min(...testSet.map(v => v.elementDur)), Math.max(...testSet.map(v => v.elementDur)));
            }

            //tidy up the display for the end...
            if (test.onErrorEnd) {
                resetTest();
                let image = new Image;
                image.src = getImageUrl();
                document.getElementById("testimg").appendChild(image);
                results.push(...new Array(TEST_RUNS - results.length % TEST_RUNS));
            }

            if (results.length < (TEST_GROUPS.length*TEST_RUNS)) {
                // if we have another test set to run, kick it off
                let nextTestIndex = TEST_GROUPS[Math.floor(results.length / TEST_RUNS)];
                resetTest();
                return sleep(1000, nextTestIndex).then(runTest);
            }



            return Promise.resolve();
        }

        // reset old test.
        // TODO: should we wait until the CPU quiets down?
        function resetTest() {
            document.getElementById("testimg").innerText = "";
        }

        /**
         * Replace the test image placeholder and collect timings from the new image
         * @param srcUrl url for the image
         * @returns {Promise<{}>} object containing the test results
         */
        async function loadImage(srcUrl) {
            let currTest = {};

            let image = new Image;

            image.elementTiming = `elementTiming`;

            // OnLoad timing
            image.onload = () => {
                currTest.onLoadEnd = performance.now();
                // RequestAnimationFrame timing
                requestAnimationFrame(() => currTest.rafEnd = performance.now());
            };
            //OnError timing
            image.onerror = () => currTest.onErrorEnd = performance.now();

            //imprecise start timing
            currTest.testStart = performance.now();

            image.src = srcUrl;
            document.getElementById("testimg").appendChild(image);

            await image.decode().catch(() => currTest.onErrorEnd = performance.now());
            currTest.decodeEnd = performance.now();
            currTest.url = image.src;
            if (!currTest.onErrorEnd) await sleep(200); // fix some race conditions

            return currTest;
        }

        function getImageUrl() {
            let url = window.location.hash || "1.gif";
            return url.replace(/^#/, '');
        }

        /**
         * selects the file to load in the <img> tag. The default is the file `1.gif` but a new file can be selected in
         * the url hash: http://localhost/index.html#cats.gif
         *
         * Using the suffix param, the extension is replaced with a different flavour of the original:
         * 1.gif -> 1.webp
         * 1.gif -> 1_avc1.mp4
         * 1.gif -> 1_hvc1.mp4
         *
         * @param suffix the replacement file extension for the test set
         */
        async function runTest(suffix) {
            let url = getImageUrl();

            if (suffix) url = url.replace(/\.[^.]+$/, suffix);

            //add `?t=` local cache busting timestamp
            let test = await loadImage(`${url}?t=${new Date().getTime()}`);
            await endTest(test);
        }

        //kick things off
        sleep(1000).then(runTest);
    </script>
</body>
</html>
